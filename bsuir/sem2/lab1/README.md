
# Лабараторная работа 1

<b>Вариант:</b> 11

<b>Постановка задачи:</b> Дерево сумм. Поиск суммы чисел на отрезке массива. Изменение всех
чисел на отрезке массива на какое-то значение.

<b>Определения:</b>

- Дерево отрезков — это структура данных, которая позволяет эффективно (т.е. за асимптотику O (log n)) реализовать операции следующего вида: нахождение суммы/минимума/максимума элементов массива в заданном отрезке (a[l...r], где l и r поступают на вход алгоритма), при этом дополнительно возможно изменение элементов массива: как изменение значения одного элемента, так и изменение элементов на целом подотрезке массива (т.е. разрешается присвоить всем элементам a[l...r] какое-либо значение, либо прибавить ко всем элементам массива какое-либо число)
- Дерево сумм — дерево отрезков реализующее операцию нахождения суммы элементов
- Сыновья корня дерева отрезков — это отрезки [0…n/2] и [n/2+1…n-1]

<b>(1) Построение</b>   
Процесс построения дерева отрезков по заданному массиву   можно делать эффективно следующим образом, снизу вверх: сначала запишем значения элементов a[i] в соответствующие листья дерева, затем на основе них посчитаем значения для вершин предыдущего уровня как сумму значений в двух листьях, затем аналогичным образом посчитаем значения для ещё одного уровня, и т.д. Удобно описывать эту операцию рекурсивно: мы запускаем процедуру построения от корня дерева отрезков, а сама процедура построения, если её вызвали не от листа, вызывает себя от каждого из двух сыновей и ищет сумму вычисленных значений, а если её вызвали от листа — то просто записывает в себя значение этого элемента массива.

<b>(2) Запрос максимума</b>  
Рассмотрим теперь запрос суммы. На вход поступают два числа l и r, и мы должны за время O(log n) найти сумму элементов на отрезке a[l…r].  
  
Для этого мы будем спускаться по построенному дереву отрезков, используя для поиска ответа найденные ранее суммы на каждой вершине дерева. Изначально мы встаём в корень дерева отрезков. Посмотрим, в какие из двух его сыновей попадает отрезок запроса [l…r]. Возможны два варианта: что отрезок [l…r] попадает только в одного сына корня, и что, наоборот, отрезок пересекается с обоими сыновьями.  
  
Первый случай прост: просто перейдём в того сына, в котором лежит наш отрезок-запрос, и применим описываемый здесь алгоритм к текущей вершине.  
  
Во втором же случае нам не остаётся других вариантов, кроме как перейти сначала в левого сына и посчитать ответ на запрос в нём, а затем — перейти в правого сына, найти в нём ответ и сравнить с нашим ответом. Иными словами, если левый сын представлял отрезок [l1…r1], а правый — отрезок [l2…r2]. (заметим, что l2=r1+1), то мы перейдём в левого сына с запросом [l…r1], а в правого — с запросом [l2…r].  


<b>(3) Запрос обновления</b>  
Запрос обновления можно реализовать как рекурсивную функцию: ей передаётся текущая вершина дерева отрезков, и эта функция выполняет рекурсивный вызов от одного из двух своих сыновей (от того, который содержит позицию i в своём отрезке), а после этого — пересчитывает значение суммы в текущей вершине точно таким же образом, как мы это делали при построении дерева отрезков (т.е. как сумма значений по обоим сыновьям текущей вершины).

# Реализованные Методы
<details>
<summary><b>Методы</b></summary>
<br />

- build

Метод создания дерева сумм(private)

- get_sum_LR

Метод нахождения суммы на промежутке \[l..r](private)

- update_LR

Метод изменения значения(private)

- update(перегружена)

Метод вызова update_LR(public)

- init

Метод вызова build(public)

- get_sum

Метод вызова get_sum_LR(public)

</details>

# Пример работы программы 
![Снимок экрана 2023-03-22 005621](https://user-images.githubusercontent.com/116163887/226758512-1651bb55-fe78-4c86-a59a-5dd9fe64ea90.png)

# Тесты
<b>Первый пример</b>

test1 = { 3,-4,7,-8,2,4,-8,-4,8,10 }
  
 Первый тест показывает работоспрособность нахожднения максимума на промежутке(l=3,r=7).  
 Ответ: -14

<b>Второй пример</b>

test2 = { 7,7,-9,3,-10,-9,5,-7,2,4 }

 Второй тест показывает работоспособность обновления значений на промежутке(l=4,r=6) на значение 8.  
 Ответ: 80

<b>Третий пример</b>

test3 = { 7,-3,-4,-6,5,-6,-2,-7,1,-3 }

 Третий тест показывает работоспособность обновления одного лемента(pos=1) на значение 10.  
 Ответ: 7

<b>Четвертый пример</b>

test4={1,2,3}

 Четвертый тест показывает работоспособность в случае когда значения l и r вне промежутка(l=-1,r=4).  
 Ответ: 13


<b>Пятый пример</b>

test5={}

 Пятый тест показывает, что будет в случает, если пытаться искать максимум и обновлять значения в пустом массиве.  
 Ответ:

# Вывод

Лабораторная работа позволила ознакомиться с более быстрым способом работы с массивами. Я ознакомился с RMQ и RSQ. Так же я ознакомился с многофайловыми проектами.

# Источники информации

1) https://e-maxx.ru/algo/segment_tree#9
